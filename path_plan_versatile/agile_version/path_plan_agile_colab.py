# -*- coding: utf-8 -*-
"""Path Plan Agile

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1QoqDbtq6gsvsowpascHgG--2q-ozRQX0

##Imports
"""

pip install pyclipper

import numpy as np
import scipy
from numpy import linalg
import math
import pyclipper
from shapely.geometry import Point, Polygon, LineString
from google.colab import files
from datetime import datetime
import random
from copy import deepcopy
import pickle
from itertools import compress

import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import animation
from IPython.display import HTML
from matplotlib import rc
from mpl_toolkits import mplot3d
import mpl_toolkits.mplot3d.axes3d as p3
import matplotlib.animation as animation

import os
import time
import argparse
import pdb

font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 15}

plt.rc('font', **font)

"""##Building Code"""

class Building():
    def __init__(self,vertices,position = None): # Buildings(obstacles) are defined by coordinates of their vertices.
        self.vertices = np.array(vertices)
        self.position = np.array(position)
        self.panels = np.array([])
        self.nop  = None           # Number of Panels
        self.K = None              # Coefficient Matrix
        self.K_inv = None
        self.gammas = {}           # Vortex Strenghts
        #self.solution = np.array([])

    def inflate(self,safetyfac = 1.1, rad = 1e-4):
        rad = rad * safetyfac
        scale = 1e6
        pco = pyclipper.PyclipperOffset()
        pco.AddPath( (self.vertices[:,:2] * scale).astype(int).tolist() , pyclipper.JT_MITER, pyclipper.ET_CLOSEDPOLYGON)

        inflated  =  np.array ( pco.Execute( rad*scale )[0] ) / scale
        height = self.vertices[0,2]
        points = np.hstack(( inflated , np.ones((inflated.shape[0],1)) *height ))
        Xavg = np.mean(points[:,0:1])
        Yavg = np.mean(points[:,1:2])
        angles = np.arctan2( ( Yavg*np.ones(len(points[:,1])) - points[:,1] ) , ( Xavg*np.ones(len(points[:,0])) - points[:,0] ) )
        sorted_angles = sorted(zip(angles, points), reverse = True)
        points_sorted = np.vstack([x for y, x in sorted_angles])
        self.vertices = points_sorted

    def panelize(self,size):
        # Divides obstacle edges into smaller line segments, called panels.
        for index,vertice in enumerate(self.vertices):
            xyz1 = self.vertices[index]                                 # Coordinates of the first vertice
            xyz2 = self.vertices[ (index+1) % self.vertices.shape[0] ]  # Coordinates of the next vertice
            s    = ( (xyz1[0]-xyz2[0])**2 +(xyz1[1]-xyz2[1])**2)**0.5   # Edge Length
            n    = math.ceil(s/size)                                    # Number of panels given desired panel size, rounded up

            if n == 1:
                self.panels = np.vstack((self.panels,np.linspace(xyz1,xyz2,n)[1:]))
                #raise ValueError('Size too large. Please give a smaller size value.')
            if self.panels.size == 0:
                self.panels = np.linspace(xyz1,xyz2,n)[1:]
            else:
            # Divide the edge into "n" equal segments:
                self.panels = np.vstack((self.panels,np.linspace(xyz1,xyz2,n)[1:]))


    def calculate_coef_matrix(self, method = 'Vortex'):
# Calculates coefficient matrix.
        if method == 'Vortex':
            self.nop = self.panels.shape[0]    # Number of Panels
            self.pcp = np.zeros((self.nop,2))  # Controlpoints: at 3/4 of panel
            self.vp  = np.zeros((self.nop,2))  # Vortex point: at 1/4 of panel
            self.pl  = np.zeros((self.nop,1))  # Panel Length
            self.pb  = np.zeros((self.nop,1))  # Panel Orientation; measured from horizontal axis, ccw (+)tive, in radians

            XYZ2 = self.panels                      # Coordinates of end point of panel
            XYZ1 = np.roll(self.panels,1,axis=0)    # Coordinates of the next end point of panel

            self.pcp  = XYZ2 + (XYZ1-XYZ2)*0.75 # Controlpoints point at 3/4 of panel. #self.pcp  = 0.5*( XYZ1 + XYZ2 )[:,:2]
            self.vp   = XYZ2 + (XYZ1-XYZ2)*0.25 # Vortex point at 1/4 of panel.
            self.pb   = np.arctan2( ( XYZ2[:,1] - XYZ1[:,1] ) , ( XYZ2[:,0] - XYZ1[:,0] ) )  + np.pi/2
            self.K = np.zeros((self.nop,self.nop))
            for m in range(self.nop ):
                for n in range(self.nop ):
                    self.K[m,n] = ( 1 / (2*np.pi)
                                    * ( (self.pcp[m][1]-self.vp[n][1] ) * np.cos(self.pb[m] ) - ( self.pcp[m][0] - self.vp[n][0] ) * np.sin(self.pb[m] ) )
                                    / ( (self.pcp[m][0]-self.vp[n][0] )**2 + (self.pcp[m][1] - self.vp[n][1] )**2 ) )
            # Inverse of coefficient matrix: (Needed for solution of panel method eqn.)
            self.K_inv = np.linalg.inv(self.K)
        elif method == 'Source':
            pass

    def gamma_calc(self,vehicle,othervehicles,arenamap,method = 'Vortex'):
    # Calculates unknown vortex strengths by solving panel method eq.

        vel_sink   = np.zeros((self.nop,2))
        vel_source = np.zeros((self.nop,2))
        vel_source_imag = np.zeros((self.nop,2))
        vel_source_imag1 = np.zeros((self.nop,2))
        vel_source_imag2 = np.zeros((self.nop,2))
        vel_source_imag3 = np.zeros((self.nop,2))
        RHS        = np.zeros((self.nop,1))

        if method == 'Vortex':
            vel_sink[:,0] = (-vehicle.sink_strength*(self.pcp[:,0]-vehicle.goal[0]))/(2*np.pi*((self.pcp[:,0]-vehicle.goal[0])**2+(self.pcp[:,1]-vehicle.goal[1])**2))
            vel_sink[:,1] = (-vehicle.sink_strength*(self.pcp[:,1]-vehicle.goal[1]))/(2*np.pi*((self.pcp[:,0]-vehicle.goal[0])**2+(self.pcp[:,1]-vehicle.goal[1])**2))
            
            vel_source_imag[:,0] = (vehicle.imag_source_strength*(self.pcp[:,0]-vehicle.position[0]))/(2*np.pi*((self.pcp[:,0]-vehicle.position[0])**2+(self.pcp[:,1]-vehicle.position[1])**2))
            vel_source_imag[:,1] = (vehicle.imag_source_strength*(self.pcp[:,1]-vehicle.position[1]))/(2*np.pi*((self.pcp[:,0]-vehicle.position[0])**2+(self.pcp[:,1]-vehicle.position[1])**2))

            for i,othervehicle in enumerate(othervehicles) :

                    vel_source[:,0] += (othervehicle.source_strength*(self.pcp[:,0]-othervehicle.position[0]))/(2*np.pi*((self.pcp[:,0]-othervehicle.position[0])**2+(self.pcp[:,1]-othervehicle.position[1])**2))
                    vel_source[:,1] += (othervehicle.source_strength*(self.pcp[:,1]-othervehicle.position[1]))/(2*np.pi*((self.pcp[:,0]-othervehicle.position[0])**2+(self.pcp[:,1]-othervehicle.position[1])**2))


            RHS[:,0]  = -vehicle.V_inf[0]  * np.cos(self.pb[:])  \
                                    -vehicle.V_inf[1]  * np.sin(self.pb[:])  \
                                    -vel_sink[:,0]     * np.cos(self.pb[:])  \
                                    -vel_sink[:,1]     * np.sin(self.pb[:])  \
                                    -vel_source[:,0]   * np.cos(self.pb[:])  \
                                    -vel_source[:,1]   * np.sin(self.pb[:])  \
                                    -vel_source_imag[:,0]  * np.cos(self.pb[:])  \
                                    -vel_source_imag[:,1]  * np.sin(self.pb[:]) 

            self.gammas[vehicle.ID] = np.matmul(self.K_inv,RHS)

"""##Arena Code"""

class ArenaMap():
    def __init__(self,number = 0, generate = 'manual'):
        self.panels = None
        self.wind = [0,0]
        self.windT = 0
        self.buildings =  []
        if generate == 'manual':
            version = number
            if version == 0:   # Dubai Map
                self.buildings = [Building([[55.1477081, 25.0890699, 50 ],[ 55.1475319, 25.0888817, 50 ],[ 55.1472176, 25.0891230, 50 ],[ 55.1472887, 25.0892549, 50],[55.1473938, 25.0893113, 50]]),
                                                    Building([[55.1481917, 25.0895323, 87 ],[ 55.1479193, 25.0892520, 87 ],[ 55.1476012, 25.0895056, 87 ],[ 55.1478737, 25.0897859, 87]]),
                                                    Building([[55.1486038, 25.0899385, 53 ],[ 55.1483608, 25.0896681, 53 ],[ 55.1480185, 25.0899204, 53 ],[ 55.1482615, 25.0901908, 53]]),
                                                    Building([[55.1490795, 25.0905518, 82 ],[ 55.1488245, 25.0902731, 82 ],[ 55.1485369, 25.0904890, 82 ],[ 55.1487919, 25.0907677, 82]]),
                                                    Building([[55.1494092, 25.0909286, 54 ],[ 55.1493893, 25.0908353, 54 ],[ 55.1493303, 25.0907662, 54 ],[ 55.1492275, 25.0907240, 54],[ 55.1491268, 25.0907304, 54],[ 55.1490341, 25.0907831, 54],[ 55.1489856, 25.0908571, 54],[ 55.1489748, 25.0909186, 54],[ 55.1489901, 25.0909906, 54],[ 55.1490319, 25.0910511, 54],[ 55.1491055, 25.0910987, 54],[ 55.1491786, 25.0911146, 54],[ 55.1492562, 25.0911063, 54],[ 55.1493356, 25.0910661, 54],[ 55.1493858, 25.0910076, 54]]),
                                                    Building([[55.1485317, 25.0885948, 73 ],[ 55.1482686, 25.0883259, 73 ],[ 55.1479657, 25.0885690, 73 ],[ 55.1482288, 25.0888379, 73]]),
                                                    Building([[55.1489093, 25.0890013, 101],[ 55.1486436, 25.0887191, 101],[ 55.1483558, 25.0889413, 101],[ 55.1486214, 25.0892235, 101]]),
                                                    Building([[55.1492667, 25.0894081, 75 ],[ 55.1489991, 25.0891229, 75 ],[ 55.1487253, 25.0893337, 75 ],[ 55.1489928, 25.0896189, 75]]),
                                                    Building([[55.1503024, 25.0903554, 45 ],[ 55.1499597, 25.0899895, 45 ],[ 55.1494921, 25.0903445, 45 ],[ 55.1497901, 25.0906661, 45],[ 55.1498904, 25.0906734, 45]]),
                                                    Building([[55.1494686, 25.0880107, 66 ],[ 55.1491916, 25.0877250, 66 ],[ 55.1490267, 25.0877135, 66 ],[ 55.1486811, 25.0879760, 66],[ 55.1490748, 25.0883619, 66]]),
                                                    Building([[55.1506663, 25.0900867, 47 ],[ 55.1503170, 25.0897181, 47 ],[ 55.1499784, 25.0899772, 47 ],[ 55.1503277, 25.0903494, 47]]),
                                                    Building([[55.1510385, 25.0898037, 90 ],[ 55.1510457, 25.0896464, 90 ],[ 55.1507588, 25.0893517, 90 ],[ 55.1503401, 25.0896908, 90],[ 55.1506901, 25.0900624, 90]])]
            # If we want to add other arenas:
            elif version == 1:
                self.buildings = [Building([[-1.5, -2.5, 1], [-2.5, -3.5 , 1], [-3.5, -2.5, 1], [-2.5, -1.5, 1]]),
                                                    Building([[ 3 ,  2, 1 ], [ 2.,  2, 1 ] ,[ 2.,  3, 1 ],[ 3.,  3, 1 ]]),
                                                    Building([[ 3.,  -1, 1 ], [ 2., -2, 1 ] ,[ 1., -2, 1 ],[ 1.,  -1, 1 ],[ 2, 0, 1 ],[ 3., 0, 1 ]]),
                                                    #Building([[ 4.1 , -3.9, 1 ], [ 4, -3.9, 1 ] ,[  4,  3.9, 1 ],[  4.1,  3.9, 1 ]]),
                                                    #Building([[ 3.9 , -4.1, 1 ], [ -3.9, -4.1, 1 ] ,[ -3.9,  -4, 1 ],[  3.9,  -4, 1 ]]),
                                                    #Building([[ 3.9 , 4, 1 ], [ -3.9, 4, 1 ] ,[ -3.9,  4.1, 1 ],[  3.9,  4.1, 1 ]]),
                                                    #Building([[ -4 , -3.9, 1 ], [ -4.1, -3.9, 1 ] ,[  -4.1,  3.9, 1 ],[  -4,  3.9, 1 ]]),
                                                    Building([[0.0, 1.0, 1], [-0.293, 0.293, 1], [-1.0, 0.0, 1], [-1.707, 0.293, 1], [-2.0, 1.0, 1], [-1.707, 1.707, 1], [-1.0, 2.0, 1], [-0.293, 1.707, 1]]),
                                                    Building([[-2.0, 3.0, 1], [-2.5, 2.134, 1], [-3.5, 2.134, 1], [-4.0, 3.0, 1], [-3.5, 3.866, 1], [-2.5, 3.866, 1]]) ]

            elif version == 2:
                self.buildings = [Building([[0.3, 1.0, 2], [0.05, 0.567, 2], [-0.45, 0.567, 2], [-0.7, 1.0, 2], [-0.45, 1.433, 2], [0.05, 1.433, 2]]),
                                                    Building([[0.3, 3.0, 1.5], [0.05, 2.567, 1.5], [-0.45, 2.567, 1.5], [-0.7, 3.0, 1.5], [-0.45, 3.433, 1.5], [0.05, 3.433, 1.5]]),
                                                    Building([[1.7, 2.0, 1.2], [1.45, 1.567, 1.2], [0.95, 1.567, 1.2], [0.7, 2.0, 1.2], [0.95, 2.433, 1.2], [1.45, 2.433, 1.2]]),
                                                    Building([[-1.07, -0.2, 1.5], [-1.5, -0.63, 1.5], [-1.93, -0.2, 1.5], [-1.5, 0.23, 1.5]]),
                                                    Building([[-1.07, -2.0, 1.5], [-1.5, -2.43, 1.5], [-1.93, -2.0, 1.5], [-1.5, -1.57, 1.5]]),
                                                    Building([[-2.57, -1.0, 1.5], [-3.0, -1.43, 1.5], [-3.43, -1.0, 1.5], [-3.0, -0.57, 1.5]]),
                                                    Building([[-2.57, 1.0, 1.5], [-3.0, 0.57, 1.5], [-3.43, 1.0, 1.5], [-3.0, 1.43, 1.5]]),
                                                    Building([[1, -2.1, 1.2], [0.5, -2.1, 1.2], [0.5, -1, 1.2], [1, -0.6, 1.2]]),
                                                    Building([[2.5, -2.1, 1.2], [2, -2.1, 1.2], [2, -0.6, 1.2], [2.5, -1, 1.2]])]
            elif version == 3:
                self.buildings = [
                                                    Building([[1.7, 2.0, 2], [1.45, 1.567, 2], [0.95, 1.567, 2], [0.7, 2.0, 2], [0.95, 2.433, 2], [1.45, 2.433, 2]])]
            elif version == 4:
                self.buildings = [Building([[0.3, 1.0, 2], [0.05, 0.567, 2], [-0.45, 0.567, 2], [-0.7, 1.0, 2], [-0.45, 1.433, 2], [0.05, 1.433, 2]]),
                                                    Building([[0.3, 3.0, 2], [0.05, 2.567, 2], [-0.45, 2.567, 2], [-0.7, 3.0, 2], [-0.45, 3.433, 2], [0.05, 3.433, 2]]),
                                                    Building([[1.7, 2.0, 2], [1.45, 1.567, 2], [0.95, 1.567, 2], [0.7, 2.0, 2], [0.95, 2.433, 2], [1.45, 2.433, 2]])]
            elif version == 41:
                self.buildings = [Building([[0.3, 1.0, 2], [0.05, 0.567, 2], [-0.45, 0.567, 2], [-0.7, 1.0, 2], [-0.45, 1.433, 2], [0.05, 1.433, 2]]),
                                                    Building([[1.7, 2.0, 2], [1.45, 1.567, 2], [0.95, 1.567, 2], [0.7, 2.0, 2], [0.95, 2.433, 2], [1.45, 2.433, 2]])]
            elif version == 5:
                self.buildings = [Building([[-3.9, 3.9, 2], [-4.1, 3.9, 2], [-4.1, 4.1, 2], [-3.9, 4.1, 2]]),
                                                    Building([[4.1, 3.9, 2], [3.9, 3.9, 2], [3.9, 4.1, 2], [4.1, 4.1, 2]]),
                                                    Building([[4.1, -4.1, 2], [3.9, -4.1, 2], [3.9, -3.9, 2], [4.1, -3.9, 2]]),
                                                    Building([[-3.9, -4.1, 2], [-4.1, -4.1, 2], [-4.1, -3.9, 2], [-3.9, -3.9, 2]])]
            elif version == 6:
                self.buildings = [Building([[3.0, 2.0, 1.2], [2.75, 1.567, 1.2], [2.25, 1.567, 1.2], [2.0, 2.0, 1.2], [2.25, 2.433, 1.2], [2.75, 2.433, 1.2]]), #AddCircularBuilding( 2.5, 2, 6, 0.5, 1.2, angle = 0)
                                                    Building([[1.0, 3.0, 1.5], [0.75, 2.567, 1.5], [0.25, 2.567, 1.5], [0.0, 3.0, 1.5], [0.25, 3.433, 1.5], [0.75, 3.433, 1.5]]), #AddCircularBuilding( 0.5, 3, 6, 0.5, 1.5, angle = 0)
                                                    Building([[1.0, 0.5, 2], [0.75, 0.067, 2], [0.25, 0.067, 2], [0.0, 0.5, 2], [0.25, 0.933, 2], [0.75, 0.933, 2]]), #AddCircularBuilding( 0.5, 0.5, 6, 0.5, 2, angle = 0)
                                                    Building([[-2.65, 1.5, 1.5], [-3.0, 1.15, 1.5], [-3.35, 1.5, 1.5], [-3.0, 1.85, 1.5]]), #AddCircularBuilding( -3, 1.5, 4, 0.35, 1.5, angle = 0)
                                                    Building([[-2.65, -1.5, 1.5], [-3.0, -1.85, 1.5], [-3.35, -1.5, 1.5], [-3.0, -1.15, 1.5]]), #AddCircularBuilding( -3, -1.5, 4, 0.35, 1.5, angle = 0)
                                                    Building([[-1.15, -0.2, 1.5], [-1.5, -0.55, 1.5], [-1.85, -0.2, 1.5], [-1.5, 0.15, 1.5]]), #AddCircularBuilding( -1.5, -0.2, 4, 0.35, 1.5, angle = 0)
                                                    Building([[1.5, -2.5, 1.2], [1, -2.5, 1.2], [1, -1.4, 1.2], [1.5, -1, 1.2]]),
                                                    Building([[3.5, -2.5, 1.2], [3, -2.5, 1.2], [3, -1, 1.2], [3.5, -1.4, 1.2]])]
            elif version == 61:
                self.buildings = [Building([[1.0, 0.5, 2], [0.75, 0.067, 2], [0.25, 0.067, 2], [0.0, 0.5, 2], [0.25, 0.933, 2], [0.75, 0.933, 2]])]
            elif version == 8:
                self.buildings = [Building([[20.0, 15.0, 40], [17.5, 10.67, 40], [12.5, 10.67, 40], [10.0, 15.0, 40], [12.5, 19.33, 40], [17.5, 19.33, 40]]), #Arena.AddCircularBuilding( 15, 15, 6, 5, 40, angle = 0)
                                                    Building([[40.0, 27.0, 40], [46.062, 23.5, 40], [46.062, 16.5, 40], [40.0, 13.0, 40], [33.938, 16.5, 40], [33.938, 23.5, 40]]), #Arena.AddCircularBuilding( 40, 20, 6, 7, 40, angle = np.pi/2)
                                                    Building([[31.0, 45.0, 40], [26.854, 39.294, 40], [20.146, 41.473, 40], [20.146, 48.527, 40], [26.854, 50.706, 40]]), #Arena.AddCircularBuilding( 25, 45, 5, 6, 40, angle = 0)
                                                    Building([[12.828, 37.828, 40], [11.035, 31.136, 40], [6.136, 36.035, 40]]), #Arena.AddCircularBuilding( 10, 35, 3, 4, 40, angle = np.pi/4) 
                                                    Building([[55.657, 45.657, 40], [55.657, 34.343, 40], [44.343, 34.343, 40], [44.343, 45.657, 40]])] #Arena.AddCircularBuilding( 50, 40, 4, 8, 40, angle = np.pi/4)
        elif generate == 'random':
            self.buildings = []
            self.buildings.append(self.AddRandomBuilding())
            while len(self.buildings) < number:
                temp_building = self.AddRandomBuilding()
                for i in range(len(self.buildings) ):
                    x = self.buildings[i].position[0]
                    y = self.buildings[i].position[1]
                    r = self.buildings[i].position[2]
                    d = ( (x-temp_building.position[0])**2 + (y-temp_building.position[1])**2 )**0.5
                    if d < r*2 + temp_building.position[2]:
                        break
                    if i == len(self.buildings)-1:
                        self.buildings.append(temp_building)


    def Inflate(self, visualize = False, radius = 1e-4):
        # Inflates buildings with given radius
        if visualize: self.Visualize2D(buildingno="All", show = False)
        for building in self.buildings:
            building.inflate(rad = radius)
        if visualize: self.Visualize2D(buildingno="All")
            #self.buildings[index].vertices[:,:2] = self.buildings[index].inflated
    def Panelize(self,size):
         # Divides building edges into smaller line segments, called panels.
        for building in self.buildings:
            building.panelize(size)

    def Calculate_Coef_Matrix(self,method = 'Vortex'):
        # !!Assumption: Seperate building interractions are neglected. Each building has its own coef_matrix
        for building in self.buildings:
            building.calculate_coef_matrix(method = method)

    def Visualize2D(self,buildingno = "All",points = "buildings", show = True):
        plt.grid(color = 'k', linestyle = '-.', linewidth = 0.5)
        #minx = -5 # min(min(building.vertices[:,0].tolist()),minx)
        #maxx = 5 # max(max(building.vertices[:,0].tolist()),maxx)
        #miny = -5 # min(min(building.vertices[:,1].tolist()),miny)
        #maxy = 5 # max(max(building.vertices[:,1].tolist()),maxy)
        #plt.xlim([minx, maxx])
        #plt.ylim([miny, maxy])
        if buildingno == "All":
            if points == "buildings":
                for building in self.buildings:
                    # plt.scatter(  np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) )
                    plt.plot(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'b' )
                    plt.fill(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'b' )
            elif points == "panels":
                for building in self.buildings:
                    plt.scatter(building.panels[:,0],building.panels[:,1])
                    plt.plot(building.panels[:,0],building.panels[:,1])
                    controlpoints = building.pcp
                    plt.scatter(controlpoints[:,0],controlpoints[:,1], marker = '*')
            if show: plt.show()
        else:
            if points == "buildings":
                building = self.buildings[buildingno]
                plt.scatter(  np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) )
                plt.plot(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) )
            elif points == "panels":
                building = self.buildings[buildingno]
                controlpoints = building.pcp
                plt.scatter(building.panels[:,0],building.panels[:,1])
                plt.scatter(controlpoints[:,0],controlpoints[:,1], marker = '*')
                plt.plot( np.vstack((building.panels[:], building.panels[0] ))[:,0], np.vstack((building.panels[:], building.panels[0]))[:,1],markersize = 0)
            if show: plt.show()

    def Visualize3D(self,buildingno = "All",show = "buildings"):
        pass

    def ScaleIntoMap(self, shape =  np.array(  ((-1,-1),(1,1))  ) ):
        pass

    def AddCircularBuilding(self, x_offset, y_offset, no_of_pts, size, height = 1, angle = 0):
        n = 6 #number of points
        circle_list = []
        #offset_x = -3
        #offset_y = 3
        #size = 1
        #height = 1
        for i in range(no_of_pts):
            delta_rad = -2*math.pi / no_of_pts * i
            circle_list.append( [round(math.cos(delta_rad)*size + x_offset,3) , round( math.sin(delta_rad)*size + y_offset,3), height] )
        print("Building(" + str(circle_list) + ")" )

    def Wind(self,wind_str = 0, wind_aoa = 0, info = 'unknown'):
        self.wind[0] = wind_str * np.cos(wind_aoa)
        self.wind[1] = wind_str * np.sin(wind_aoa)
        if info == 'known':
            self.windT = 1
        elif info == 'unknown':
            self.windT = 0

    def AddRandomBuilding(self):
            center_x = round(random.uniform(-3, 3),3)
            center_y = round(random.uniform(-3, 3),3)
            #radius = round(random.uniform(0.25, 1),3)
            radius = round(random.uniform(0.25, 1.5),3)
            position = np.array([center_x, center_y, radius ])
            n = random.randint(3, 10) # number of vertices
            height = round(random.uniform(1.25, 2),3)
            circle_list = []
            theta = np.sort(np.random.rand(n)*2*np.pi)  ## Generate n random numbers btw 0-2pi and sort: small to large
            for j in range(n):
                circle_list.append( [round(math.cos(theta[j])*radius + center_x,3) , round( math.sin(theta[j])*radius  + center_y,3), height] )   ######
            return Building(circle_list,position)  ########

"""##Vehicles"""

def dynamics(X, t, U):
    '''  Dynamic model :
    Xdot   = X(k+1) - X(k)
    X(k+1) = AX(k)  + BU(k)
    where X : [PE,PN,PU,Vx,Vy,Vz] Elem R6
    U : [VdesE, VdesN, VdesU]
    X = X0 + V*t
    V = V0 + a*t
    '''
    k = 1.140
    A = np.array([[1.,  0.,  0.,  t,      0.,     0.    ],
                                [0.,  1.,  0.,  0.,     t,      0.    ],
                                [0.,  0.,  1.,  0.,     0.,     t     ],
                                [0.,  0.,  0.,  1.-k*t, 0.,     0.    ],
                                [0.,  0.,  0.,  0.,     1.-k*t, 0.    ],
                                [0.,  0.,  0.,  0.,     0.,     1.-k*t]])
    B = np.array([[0.,  0.,  0. ],
                                [0.,  0.,  0. ],
                                [0.,  0.,  0. ],
                                [k*t, 0.,  0. ],
                                [0.,  k*t, 0. ],
                                [0.,  0.,  k*t]])

    Xdot = A@X + B@U - X
    return Xdot
def curvature(x,y):
    dx  = np.gradient(x)
    ddx = np.gradient(dx)
    dy  = np.gradient(y)
    ddy = np.gradient(dy)
    k   = np.abs((dx*ddy - dy*ddx))/(dx*dx + dy*dy)**(3/2)
    return k
    
def line(p1, p2):
        A = (p1[1] - p2[1])
        B = (p2[0] - p1[0])
        C = (p1[0]*p2[1] - p2[0]*p1[1])
        return A, B, -C

def intersection(L1, L2):
        D  = L1[0] * L2[1] - L1[1] * L2[0]
        Dx = L1[2] * L2[1] - L1[1] * L2[2]
        Dy = L1[0] * L2[2] - L1[2] * L2[0]
        if D != 0:
                x = Dx / D
                y = Dy / D
                return True
        else:
                return False

class Vehicle():
    def __init__(self,ID,source_strength = 0, imag_source_strength = 0.75, correction_type = 'none'):
        self.t               = 0
        self.position        = np.array([0,0,0])
        self.desiredpos      = np.array([0,0,0])
        self.correction      = np.array([0,0,0])
        self.velocity        = np.array([0,0,0])
        self.goal            = None
        self.source_strength = source_strength
        self.imag_source_strength = imag_source_strength
        self.gamma           = 0
        self.altitude_mask   = None
        self.ID              = ID
        self.path            = []
        self.state           = 0
        self.velocitygain    = 1/50 # 1/300 or less for vortex method, 1/50 for hybrid
        self.correction_type = correction_type

    def Set_Position(self,pos):
        self.position = np.array(pos)
        self.path     = np.array(pos)

    def Set_Goal(self,goal,goal_strength,safety):
        self.goal          = np.array(goal)
        self.sink_strength = goal_strength
        self.safety = safety
        self.aoa = np.arctan2(self.goal[1]-self.position[1],self.goal[0]-self.position[0])
        
    def Go_to_Goal(self, altitude = 1.5, AoAsgn = 0, t_start = 0, Vinfmag = 0):
        self.AoA = (np.arctan2(self.goal[1]-self.position[1],self.goal[0]-self.position[0])) + AoAsgn*np.pi/2
        

        '''
        print( " AoA "    +  str( self.AoA*180/np.pi ) )
        print( " goal "   +  str( self.goal ) )
        print( " pos "    +  str( self.position ) )
        print( " AoAsgn " +  str( AoAsgn ) )
        print( " arctan " +  str( (np.arctan2(self.goal[1]-self.position[1],self.goal[0]-self.position[0]))*180/np.pi ) )
        '''
        self.altitude = altitude
        self.Vinfmag = Vinfmag                                      # Cruise altitude
        self.V_inf    = np.array([self.Vinfmag*np.cos(self.AoA), self.Vinfmag*np.sin(self.AoA)]) # Freestream velocity. AoA is measured from horizontal axis, cw (+)tive
        self.t = t_start

    def Source_Points(self):
        v = self.position[:2]
        g = self.goal[:2]
        beta = np.pi/2 #2*np.pi/3
        d = 0.1
        R2 = np.array([[np.cos(beta), -np.sin(beta)],[np.sin(beta),np.cos(beta)]])
        R3 = np.array([[np.cos(-beta), -np.sin(-beta)],[np.sin(-beta),np.cos(-beta)]])
        p1 = ((g-v) / linalg.norm(g-v))*d
        p2 = np.matmul(R2,p1)
        p3 = np.matmul(R3,p1)
        p1 = v - p1
        p2 = v + p2
        p3 = v + p3      
        return p1, p2, p3

    def Update_Velocity(self,flow_vels,arenamap):
    # K is vehicle speed coefficient, a design parameter
        #flow_vels = flow_vels * self.velocitygain
        V_des = flow_vels
        mag = np.linalg.norm(V_des)
        V_des_unit = V_des/mag
        V_des_unit[2] = 0
        mag = np.clip(mag, 0., 1) #0.3 tello 0.5 pprz
        mag_converted = mag # This is Tellos max speed 30Km/h
        flow_vels2 = V_des_unit * mag_converted
        flow_vels2 = flow_vels2 * self.velocitygain
        prevpos = self.position
        self.desiredpos = self.position + np.array(flow_vels2)
        self.position   = self.position + np.array(flow_vels2)  + np.array([arenamap.wind[0], arenamap.wind[1], 0]) +  self.correction
        dif1 = self.position  -prevpos
        dif2 = self.desiredpos-prevpos
        dif3 = self.position  -self.desiredpos
        if self.correction_type == 'none':
            self.correction      = np.array([0,0,0])
        elif self.correction_type == 'all':
            self.correction = self.desiredpos-self.position + self.correction
        elif self.correction_type == 'project':
            self.correction = -(dif3 - np.dot(dif3,dif2/np.linalg.norm(dif2))*np.linalg.norm(dif2) ) + self.correction
        self.path = np.vstack(( self.path,self.position ))
        if np.linalg.norm(self.goal-self.position) < 0.2: #0.1 for 2d
            self.state = 1
        return self.position

    def Update_Position(self):
        self.position = self.Velocity_Calculate(flow_vels)
    

    def propagate_future_path(self,  maglist ,dyn=dynamics, t0=0., dt=0.02, hor = 2.4,reset_position=True, set_best_state=True):
        Xe           = np.hstack([self.position,self.velocity])
        time_horizon = np.arange(t0 + dt, t0 + hor, dt)
        vinfmag_list = maglist
        #vinfmag_list = [0.05, 0.025,  0. ,  -0.025, -0.05]
        #vinfmag_list = [0.05, 0.025, 0.01, 0. , -0.01, -0.025, -0.05]
        path         = np.zeros((len(vinfmag_list),len(time_horizon),6))

#   vinfmag_list = [0.2, 0.1, 0.05, 0. , -0.05, -0.1, -0.2]
        for k,vinfmag_ in enumerate(vinfmag_list):
            X0 = Xe.copy()
            ti = t0
            self.Vinfmag = np.abs(vinfmag_)
            for i, t_ in enumerate(time_horizon):
                self.AoA   = (np.arctan2(self.goal[1]-X0[1],self.goal[0]-X0[0])) + np.sign(vinfmag_)*np.pi/2
                self.V_inf = np.array([self.Vinfmag*np.cos(self.AoA), self.Vinfmag*np.sin(self.AoA)])
                # FIX ME : This will only work because we have only one vehicle...
                flow_vels = Flow_Velocity_Calculation(current_vehicle_list, Arena, method = 'Vortex')
                V_des = flow_vels[0]
                mag = np.linalg.norm(V_des)
                V_des_unit = V_des/mag
                V_des_unit[2] = 0
                mag = np.clip(mag, 0., 1) #0.3 tello 0.5 pprz
                flow_vels2 = V_des_unit * mag
                U = flow_vels2 #* self.velocitygain
                X = scipy.integrate.odeint(dyn, X0, [ti, t_], args=(U,))
                X0 = X[1].copy()
                ti = t_
                path[k,i]     = X[1][:6] # Recording position and velocity to the path
                self.position = X[1][:3]
                self.velocity = X[1][3:6]
        if reset_position:
            self.position[:] = Xe[:3]
            self.velocity[:] = Xe[3:]
        if set_best_state:
            best = np.argmin([np.sum(curvature(path[i, 30:, 0],path[i, 30:, 1])) for i in range(len(vinfmag_list))])
            self.position[:] = Xe[:3]
            self.velocity[:] = Xe[3:]
            '''
            self.position = path[best,-1, :3]
            self.velocity = path[best,-1, 3:6]
            '''
        return path
    def propagate_simple_path(self, vinfmag, arenamap ,dyn=dynamics, t0=0., dt=0.02, hor = 2.4,reset_position=True):
        Xe           = np.hstack([self.position,self.velocity])
        time_horizon = np.arange(t0 + dt, t0 + hor, dt)
        path         = np.zeros((len(time_horizon),6))
        X0 = Xe.copy()
        ti = t0
        flow_vels = Flow_Velocity_Calculation(current_vehicle_list, arenamap, method = 'Source')
        V_des = flow_vels[0]
        mag = np.linalg.norm(V_des)
        V_des_unit = V_des/mag
        V_des_unit[2] = 0
        mag = np.clip(mag, 0., 1) #0.3 tello 0.5 pprz
        flow_vels2 = V_des_unit * mag
        U = flow_vels2 #* self.velocitygain
        for i, t_ in enumerate(time_horizon):
            # FIX ME : This will only work because we have only one vehicle...
            X = X0[:3] + U*dt #scipy.integrate.odeint(dyn, X0, [ti, t_], args=(U,))
            X0 = X.copy()
            ti = t_
            path[i,:]     = np.hstack([X,U]) # Recording position and velocity to the path
        if reset_position:
            self.position[:] = Xe[:3]
            self.velocity[:] = Xe[3:]
        future_line = line((path[0,:2]),(path[-1,:2]))  
        for building in arenamap.buildings:
            vertice_list = np.vstack((building.vertices, building.vertices[0]))
            for vert in range(building.vertices.shape[0]-1):
                polygon_line = line((vertice_list[vert]),(vertice_list[vert+1]))      
                if intersection(future_line , polygon_line) == True:
                    vinfmag = vinfmag
                elif intersection(future_line , polygon_line) == False:
                    vinfmag = 0
        return path, vinfmag

"""# Cases"""

class Cases():
    def __init__(self,number,arenamap, generate = 'manual'):
        if generate == 'manual':
            version = number
            if version == 61:
                Vehicle1 = Vehicle("V1",0,0.5)             # Vehicle ID, Source_strength,safety
                Vehicle_list = [Vehicle1]

                Vehicle1.Set_Position([ -2, 0.5, 0.50])
                Vehicle1.Set_Goal([3, 0.5, 0.5], 5, 0 )       # goal,goal_strength 30, safety 0.001
                Vehicle1.Go_to_Goal(1.5, 0,0)               # altitude,AoAsgn,t_start,Vinfmag
            elif version == 31:
                Vehicle1 = Vehicle("V1",0,0.1)            # Vehicle ID, Source_strength
                Vehicle2 = Vehicle("V2",0,0.1)
                Vehicle3 = Vehicle("V3",0,0)
                Vehicle4 = Vehicle("V4",0,0)
                Vehicle5 = Vehicle("V5",0,0)
                Vehicle6 = Vehicle("V6",0,0)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5,Vehicle6]

                Vehicle1.Set_Position([ -2, 2, 0.50])
                Vehicle2.Set_Position([-1.999, 2, 0.50])
                Vehicle3.Set_Position([-2.002, 2, 0.50])
                Vehicle4.Set_Position([-1.998, 2, 0.50])
                Vehicle5.Set_Position([-1.9985, 2, 0.50])
                Vehicle6.Set_Position([-2.0015, 2, 0.50])

                Vehicle1.Set_Goal([3, 2, 0.5], 5, 0)       # goal,goal_strength 30, safety 0.001 for vortex method
                Vehicle2.Set_Goal([3, 2, 0.5], 5, 0)
                Vehicle3.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle4.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle5.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle6.Set_Goal([3, 2, 0.2], 5, 0)

                Vehicle1.Go_to_Goal(1.5,0,0,0)         # altitude,AoAsgn,t_start,Vinfmag
                Vehicle2.Go_to_Goal(1.5,0,0,0.1)
                Vehicle3.Go_to_Goal(1.5,0,0,0.1)
                Vehicle4.Go_to_Goal(1.5,0,0,0.3)
                Vehicle5.Go_to_Goal(1.5,0,0,0.4)
                Vehicle6.Go_to_Goal(1.5,0,0,0.5)
            elif version == 71:
                Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength,safety
                Vehicle2 = Vehicle("V2",0,0.5)
                Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle4 = Vehicle("V4",0,0.5)
                Vehicle5 = Vehicle("V5",0,0.5)
                Vehicle6 = Vehicle("V6",0,0.5)
                Vehicle7 = Vehicle("V7",0,0.5)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5,Vehicle6,Vehicle7]

                Vehicle1.Set_Position([ -2, 3, 0.50])
                Vehicle2.Set_Position([-1.999, 2, 0.50])
                Vehicle3.Set_Position([-2.002, 2, 0.50])
                Vehicle4.Set_Position([-1.99, 2, 0.50])
                Vehicle5.Set_Position([-1.995, 2, 0.50])
                Vehicle6.Set_Position([-2.0015, 2, 0.50])
                Vehicle7.Set_Position([-2.001, 2, 0.50])

                Vehicle1.Set_Goal([3, 2, 0.5], 5, 0, 0    )       # goal,goal_strength 30, safety 0.001, Vinfmag=0.5,0.5,1.5 for vortex method
                Vehicle2.Set_Goal([3, 2, 0.5], 5, 0, 0.01 )
                Vehicle3.Set_Goal([3, 2, 0.2], 5, 0, 0.01 )
                Vehicle4.Set_Goal([3, 2, 0.2], 5, 0, 0.025)
                Vehicle5.Set_Goal([3, 2, 0.2], 5, 0, 0.025)
                Vehicle6.Set_Goal([3, 2, 0.2], 5, 0, 0.05 )
                Vehicle7.Set_Goal([3, 2, 0.2], 5, 0, 0.05 )

                Vehicle1.Go_to_Goal(1.5, 0,0)         # altitude,AoAsgn,t_start,
                Vehicle2.Go_to_Goal(1.5, 1,0)
                Vehicle3.Go_to_Goal(1.5, 1,0)
                Vehicle4.Go_to_Goal(1.5, 1,0)
                Vehicle5.Go_to_Goal(1.5,-1,0)
                Vehicle6.Go_to_Goal(1.5,-1,0)
                Vehicle7.Go_to_Goal(1.5,-1,0)
            elif version == 72:
                Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength,safety
                Vehicle2 = Vehicle("V2",0,0.5)
                Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle4 = Vehicle("V4",0,0.5)
                Vehicle5 = Vehicle("V5",0,0.5)
                Vehicle6 = Vehicle("V6",0,0.5)
                Vehicle7 = Vehicle("V7",0,0.5)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5,Vehicle6,Vehicle7]

                Vehicle1.Set_Position([0  ,    3, 0.50])
                Vehicle2.Set_Position([0.002,  3, 0.50])
                Vehicle3.Set_Position([-0.002, 3, 0.50])
                Vehicle4.Set_Position([0.001,  3, 0.50])
                Vehicle5.Set_Position([0.0015, 3, 0.50])
                Vehicle6.Set_Position([-0.0015,3, 0.50])
                Vehicle7.Set_Position([-0.001, 3, 0.50])

                Vehicle1.Set_Goal([2, 0, 0.5], 5, 0, 0    )       # goal,goal_strength 30, safety 0.001, Vinfmag=0.5,0.5,1.5 for vortex method
                Vehicle2.Set_Goal([2, 0, 0.5], 5, 0, 0.01 )
                Vehicle3.Set_Goal([2, 0, 0.5], 5, 0, 0.01 )
                Vehicle4.Set_Goal([2, 0, 0.5], 5, 0, 0.025)
                Vehicle5.Set_Goal([2, 0, 0.5], 5, 0, 0.025)
                Vehicle6.Set_Goal([2, 0, 0.5], 5, 0, 0.05 )
                Vehicle7.Set_Goal([2, 0, 0.5], 5, 0, 0.05 )

                Vehicle1.Go_to_Goal(1.5, 0,0)         # altitude,AoAsgn,t_start,
                Vehicle2.Go_to_Goal(1.5, 1,0)
                Vehicle3.Go_to_Goal(1.5, 1,0)
                Vehicle4.Go_to_Goal(1.5, 1,0)
                Vehicle5.Go_to_Goal(1.5,-1,0)
                Vehicle6.Go_to_Goal(1.5,-1,0)
                Vehicle7.Go_to_Goal(1.5,-1,0)
            elif version == 73:
                Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength,safety
                Vehicle_list = [Vehicle1]

                Vehicle1.Set_Position([0  ,3, 0.50])
                Vehicle1.Set_Goal([2, 0, 0.5], 5, 0)       # goal,goal_strength 30, safety 0.001
                Vehicle1.Go_to_Goal(1.5, 0,0)              # altitude,AoAsgn,t_start,Vinfmag
            elif version == 74:
                Vehicle1 = Vehicle("V1",0,0.5)             # Vehicle ID, Source_strength,safety
                Vehicle_list = [Vehicle1]

                Vehicle1.Set_Position([ -2, 2, 0.50])
                Vehicle1.Set_Goal([3, 2, 0.5], 5, 0.0005 )       # goal,goal_strength 30, safety 0.001
                Vehicle1.Go_to_Goal(1.5, 0,0)               # altitude,AoAsgn,t_start,Vinfmag
            elif version == 75:
                Vehicle1 = Vehicle("V1",0,0.5)             # Vehicle ID, Source_strength,safety
                Vehicle_list = [Vehicle1]

                Vehicle1.Set_Position([ 3, 0.5, 0.50])
                Vehicle1.Set_Goal([-2.5, 0.5, 0.5], 5, 0.00 )       # goal,goal_strength 30, safety 0.001
                Vehicle1.Go_to_Goal(1.5, 0,0)               # altitude,AoAsgn,t_start,Vinfmag

            elif version == 0:
                Vehicle1 = Vehicle("V1",0,0)            # Vehicle ID, Source_strength
                Vehicle2 = Vehicle("V2",0,0.1)
                Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle4 = Vehicle("V4",0,1)
                Vehicle5 = Vehicle("V5",0,2.5)
                Vehicle6 = Vehicle("V6",0,25)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5,Vehicle6]

                Vehicle1.Set_Goal([3, 2, 0.5], 5, 0)       # goal,goal_strength 30, safety 0.001 for vortex method
                Vehicle2.Set_Goal([3, 2, 0.5], 5, 0)
                Vehicle3.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle4.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle5.Set_Goal([3, 2, 0.2], 5, 0)
                Vehicle6.Set_Goal([3, 2, 0.2], 5, 0)

                Vehicle1.Go_to_Goal(1.5,0,0,0)         # altitude,AoAsgn,t_start,Vinfmag
                Vehicle2.Go_to_Goal(1.5,0,0,1)
                Vehicle3.Go_to_Goal(1.5,0,0,2)
                Vehicle4.Go_to_Goal(1.5,0,0,3)
                Vehicle5.Go_to_Goal(1.5,0,0,4)
                Vehicle6.Go_to_Goal(1.5,0,0,5)

                Vehicle1.Set_Position([ -2, 2, 0.50])
                Vehicle2.Set_Position([-1.999, 2, 0.50])
                Vehicle3.Set_Position([-2.002, 2, 0.50])
                Vehicle4.Set_Position([-1.998, 2, 0.50])
                Vehicle5.Set_Position([-1.9985, 2, 0.50])
                Vehicle6.Set_Position([-2.0015, 2, 0.50])
            elif version == 8:
                Vehicle1 = Vehicle("V1",0,0.85)            # Vehicle ID, Source_strength, im 0.85 veh 0.95
                Vehicle2 = Vehicle("V2",2,0.85)

                Vehicle_list = [Vehicle1,Vehicle2] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([1.5, -3, 0.5], 5, 0)       # for arena 6  [1.5, -3.3, 0.5]
                Vehicle2.Set_Goal([1.50001, -2, 0.5] , 5, 0)   # for arena 6 [2.0001, -2.3, 0.5]

                Vehicle1.Go_to_Goal(0.5,-np.pi/2,0,0.5)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)

                Vehicle1.Set_Position([2, 1.5, 0.50])   #for arena 6 [2.5, 0.5, 0.50]
                Vehicle2.Set_Position([1.5, -2 , 0.5])     #for arena 6 [2, -2.3 , 0.5]
            elif version == 1171:
                #Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength imaginary source = 1.5
                Vehicle2 = Vehicle("V2",0,0.5)
                #Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle_list = [Vehicle2] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3] Vehicle1,Vehicle2,

                #Vehicle1.Set_Goal([-3, 0, 0.5], 5, 0.000)       # goal,goal_strength all 5, safety 0.001 for V1 safety = 0 when there are sources
                Vehicle2.Set_Goal([2, 3.5, 0.5], 5, 0.000)
                #Vehicle3.Set_Goal([2, 1, 0.5], 5, 0.000)

                #Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)        # np.arctan2(3.5+1,1.5+0.5) = 1.1525719 rad
                #Vehicle3.Go_to_Goal(0.5,0,0,0)

                #Vehicle1.Set_Position([3, 1 , 0.5])
                Vehicle2.Set_Position([-1, -3 , 0.5])
                #Vehicle3.Set_Position([-3, 3 , 0.5])   
            elif version == 117:
                Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength imaginary source = 1.5
                Vehicle2 = Vehicle("V2",0,0.5)
                Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([-3, 0, 0.5], 5, 0.000)       # goal,goal_strength all 5, safety 0.001 for V1 safety = 0 when there are sources
                Vehicle2.Set_Goal([2, 3.5, 0.5], 5, 0.000)
                Vehicle3.Set_Goal([2, 1, 0.5], 5, 0.000)

                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)        # np.arctan2(3.5+1,1.5+0.5) = 1.1525719 rad
                Vehicle3.Go_to_Goal(0.5,0,0,0)

                Vehicle1.Set_Position([3, 1 , 0.5])
                Vehicle2.Set_Position([-1, -3 , 0.5])
                Vehicle3.Set_Position([-3, 3 , 0.5])        
            elif version == 11:
                Vehicle1 = Vehicle("V1",0,0.5)            # Vehicle ID, Source_strength imaginary source = 1.5
                Vehicle2 = Vehicle("V2",0,0.5)
                Vehicle3 = Vehicle("V3",0,0.5)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([-3, 0, 0.5], 5, 0.00)       # goal,goal_strength all 5, safety 0.001 for V1 safety = 0 when there are sources
                Vehicle2.Set_Goal([2, 3.5, 0.5], 5, 0.00)
                Vehicle3.Set_Goal([2, 1, 0.5], 5, 0.00)

                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)        # np.arctan2(3.5+1,1.5+0.5) = 1.1525719 rad
                Vehicle3.Go_to_Goal(0.5,0,0,0)

                Vehicle1.Set_Position([3, 1 , 0.5])
                Vehicle2.Set_Position([-1, -3 , 0.5])
                Vehicle3.Set_Position([-3, 3 , 0.5])
            elif version == 12:
                Vehicle1 = Vehicle("V1",0,0.85)            # Vehicle ID, Source_strength imaginary source = 0.75
                Vehicle2 = Vehicle("V2",0.75,0.85)
                Vehicle3 = Vehicle("V3",0,0.85)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([2.5, -3.5, 0.5], 5, 0.0000)       # goal,goal_strength all 5, safety 0.001 for V1 safety = 0 when there are sources
                Vehicle2.Set_Goal([-0.5, 3 , 0.5], 5, 0.00000)
                Vehicle3.Set_Goal([3, 3, 0.5], 5, 0.00000)

                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)
                Vehicle3.Go_to_Goal(0.5,0,0,0)

                Vehicle1.Set_Position([-2, 3 , 0.5])
                Vehicle2.Set_Position([-2, -3, 0.5])
                Vehicle3.Set_Position([-3, 0, 0.5])
            elif version == 121:
                Vehicle1 = Vehicle("V1",0,0.85)            # Vehicle ID, Source_strength imaginary source = 0.75
                Vehicle_list = [Vehicle1] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]
                Vehicle1.Set_Position([-2, 3 , 0.5])
                Vehicle1.Set_Goal([2.5, -3.5, 0.5], 5, 0.0000)       # goal,goal_strength all 5, safety 0.001 for V1 safety = 0 when there are sources
                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
            elif version == 13:
                Vehicle1 = Vehicle("V1",0.25)            # Vehicle ID, Source_strength
                Vehicle2 = Vehicle("V2",0.5)
                Vehicle3 = Vehicle("V3",0.25)
                Vehicle4 = Vehicle("V4",0.5)
                Vehicle5 = Vehicle("V5",0.5)
                Vehicle6 = Vehicle("V6",0.5)
                Vehicle7 = Vehicle("V7",0.25)
                Vehicle8 = Vehicle("V8",0.5)
                Vehicle9 = Vehicle("V9",0.25)
                Vehicle10 = Vehicle("V10",0.5)
                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5,Vehicle6,Vehicle7,Vehicle8,Vehicle9,Vehicle10] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([3   , 0.5, 0.5], 5, 0)       # goal,goal_strength 30, safety 0.001 for vortex method
                Vehicle2.Set_Goal([2.5 ,-3.5, 0.5], 5, 0)
                Vehicle3.Set_Goal([-1  , 3  , 0.5], 5, 0)
                Vehicle4.Set_Goal([-1  ,-3  , 0.5], 5, 0)
                Vehicle5.Set_Goal([-3  , 0  , 0.5], 5, 0)
                Vehicle6.Set_Goal([2   , 1  , 0.5], 5, 0)
                Vehicle7.Set_Goal([3   , 3.7, 0.5], 5, 0)
                Vehicle8.Set_Goal([-1  ,-1  , 0.5], 5, 0)
                Vehicle9.Set_Goal([2.2 ,-2  , 0.5], 5, 0)
                Vehicle10.Set_Goal([-0.5,-1  , 0.5], 5, 0)

                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)
                Vehicle3.Go_to_Goal(0.5,0,0,0)
                Vehicle4.Go_to_Goal(0.5,0,0,0)
                Vehicle5.Go_to_Goal(0.5,0,0,0)
                Vehicle6.Go_to_Goal(0.5,0,0,0)
                Vehicle7.Go_to_Goal(0.5,0,0,0)
                Vehicle8.Go_to_Goal(0.5,0,0,0)
                Vehicle9.Go_to_Goal(0.5,0,0,0)
                Vehicle10.Go_to_Goal(0.5,0,0,0)

                Vehicle1.Set_Position([-2  , 2, 0.5])
                Vehicle2.Set_Position([-2  , 1, 0.5])
                Vehicle3.Set_Position([0   ,-2, 0.5])
                Vehicle4.Set_Position([-3  , 3, 0.5])
                Vehicle5.Set_Position([3   , 0, 0.5])
                Vehicle6.Set_Position([-0.5,-3, 0.5])
                Vehicle7.Set_Position([-2  , 3, 0.5])
                Vehicle8.Set_Position([-3  ,-3, 0.5])
                Vehicle9.Set_Position([3.8 , 2, 0.5])
                Vehicle10.Set_Position([1  , 2, 0.5])
            elif version == 131:
                Vehicle1 = Vehicle("V1",0,0.75)            # Vehicle ID, Source_strength
                Vehicle2 = Vehicle("V2",0,0.75)
                Vehicle3 = Vehicle("V3",0,0.75)
                Vehicle4 = Vehicle("V4",0,0.75)
                Vehicle5 = Vehicle("V5",0,0.75)


                Vehicle_list = [Vehicle1,Vehicle2,Vehicle3,Vehicle4,Vehicle5] #, Vehicle2, Vehicle3] # , Vehicle2, Vehicle3]

                Vehicle1.Set_Goal([-2  ,  3, 0.5], 5, 0)       # goal,goal_strength 30, safety 0.001 for vortex method
                Vehicle2.Set_Goal([ 3  ,  -0.2, 0.5], 5, 0)
                Vehicle3.Set_Goal([-3  ,  0.5, 0.5], 5, 0)
                Vehicle4.Set_Goal([ 3  ,3.5, 0.5], 5, 0)
                Vehicle5.Set_Goal([-0.5 , -3, 0.5], 5, 0)



                Vehicle1.Go_to_Goal(0.5,0,0,0)         # altitude,AoA,t_start,Vinf=0.5,0.5,1.5
                Vehicle2.Go_to_Goal(0.5,0,0,0)
                Vehicle3.Go_to_Goal(0.5,0,0,0)
                Vehicle4.Go_to_Goal(0.5,0,0,0)
                Vehicle5.Go_to_Goal(0.5,0,0,0)



                Vehicle1.Set_Position([-0.5 , -3, 0.5])
                Vehicle2.Set_Position([-2  ,  3, 0.5])
                Vehicle3.Set_Position([ 3  ,  -0.2, 0.5])
                Vehicle4.Set_Position([-3  , 0.5, 0.5])
                Vehicle5.Set_Position([ 3  ,3.5, 0.5])
                


        if generate == 'random':
            no_of_vehicles = number
            Vehicle_list = []
            for no in range(no_of_vehicles):
                Vehicle_list.append(self.SetRandomStartGoal(arenamap,"V" + str(no)))
        self.Vehicle_list = Vehicle_list

    def SetRandomStartGoal(self,arenamap,ID):
        loop = True
        while loop == True:
            goal_temp  = [round(random.uniform(-3.5, 3.5),1),round(random.uniform(-3.5, 3.5),1),0.5]
            start_temp = [round(random.uniform(-3.5, 3.5),1),round(random.uniform(-3.5, 3.5),1),0.5]
            d = ( (goal_temp[0]-start_temp[0])**2 + (goal_temp[1]-start_temp[1])**2 )**0.5
            if d > 1:
                for i in range(len(arenamap.buildings) ):
                    x = arenamap.buildings[i].position[0]
                    y = arenamap.buildings[i].position[1]
                    r = arenamap.buildings[i].position[2]
                    d_goal  = ( (x-goal_temp[0])**2  + (y-goal_temp[1])**2 )**0.5
                    d_start = ( (x-start_temp[0])**2 + (y-start_temp[1])**2 )**0.5
                    if d_goal < r*2:
                        break
                    elif d_start < r*2:
                        break
                    if i == len(arenamap.buildings)-1:
                        goal_position  = goal_temp
                        start_position = start_temp
                        loop = False
        vs = round(random.uniform(0, 0.5),2)
        Vehicle_ = Vehicle(ID,vs,0.65)
        Vehicle_.Set_Goal(goal_position, 5, 0.0005) # SET VEHICLE SAFETY BACK TO 0.000
        Vehicle_.Set_Position(start_position)
        Vehicle_.Go_to_Goal(0.5,0,0,0)
        return Vehicle_

"""# Velocity Calculation"""

def Flow_Velocity_Calculation(vehicles, arenamap, method = 'Vortex', update_velocities = True):

    starttime = datetime.now()

    # Calculating unknown vortex strengths using panel method:
    for f,vehicle in enumerate(vehicles):
        # Remove current vehicle from vehicle list.
        othervehicleslist = vehicles[:f] + vehicles[f+1:]

        # Remove buildings with heights below cruise altitue:
        vehicle.altitude_mask = np.zeros(( len(arenamap.buildings) )) #, dtype=int)
        for index,panelledbuilding in enumerate(arenamap.buildings):
            if (panelledbuilding.vertices[:,2] > vehicle.altitude).any():
                vehicle.altitude_mask[index] = 1
        related_buildings = list(compress(arenamap.buildings,vehicle.altitude_mask))

        # Vortex strenght calculation (related to panels of each building):
        for building in related_buildings:
            building.gamma_calc(vehicle,othervehicleslist,arenamap,method = method)

    #--------------------------------------------------------------------
    # Flow velocity calculation given vortex strengths:
    flow_vels = np.zeros([len(vehicles),3])

    # Wind velocity
    #U_wind = arenamap.wind[0] #* np.ones([len(vehicles),1])
    #V_wind = arenamap.wind[1] #* np.ones([len(vehicles),1])

    V_gamma   = np.zeros([len(vehicles),2]) # Velocity induced by vortices
    V_sink    = np.zeros([len(vehicles),2]) # Velocity induced by sink element
    V_source  = np.zeros([len(vehicles),2]) # Velocity induced by source elements
    V_sum     = np.zeros([len(vehicles),2]) # V_gamma + V_sink + V_source
    V_normal  = np.zeros([len(vehicles),2]) # Normalized velocity
    V_flow    = np.zeros([len(vehicles),2]) # Normalized velocity inversly proportional to magnitude
    V_norm    = np.zeros([len(vehicles),1]) # L2 norm of velocity vector

    W_sink    = np.zeros([len(vehicles),1]) # Velocity induced by 3-D sink element
    W_source  = np.zeros([len(vehicles),1]) # Velocity induced by 3-D source element
    W_flow    = np.zeros([len(vehicles),1]) # Vertical velocity component (to be used in 3-D scenarios)
    W_sum     = np.zeros([len(vehicles),1])
    W_norm    = np.zeros([len(vehicles),1])
    W_normal  = np.zeros([len(vehicles),1])

    for f,vehicle in enumerate(vehicles):

        # Remove current vehicle from vehicle list
        othervehicleslist = vehicles[:f] + vehicles[f+1:]

        # Velocity induced by 2D point sink, eqn. 10.2 & 10.3 in Katz & Plotkin:
        V_sink[f,0] = (-vehicle.sink_strength*(vehicle.position[0]-vehicle.goal[0]))/(2*np.pi*((vehicle.position[0]-vehicle.goal[0])**2+(vehicle.position[1]-vehicle.goal[1])**2))
        V_sink[f,1] = (-vehicle.sink_strength*(vehicle.position[1]-vehicle.goal[1]))/(2*np.pi*((vehicle.position[0]-vehicle.goal[0])**2+(vehicle.position[1]-vehicle.goal[1])**2))
        # Velocity induced by 3-D point sink. Katz&Plotkin Eqn. 3.25
        W_sink[f,0] = (-vehicle.sink_strength*(vehicle.position[2]-vehicle.goal[2]))/(4*np.pi*(((vehicle.position[0]-vehicle.goal[0])**2+(vehicle.position[1]-vehicle.goal[1])**2+(vehicle.position[2]-vehicle.goal[2])**2)**1.5))

        # Velocity induced by 2D point source, eqn. 10.2 & 10.3 in Katz & Plotkin:
        source_gain = 0
        for othervehicle in othervehicleslist:
            V_source[f,0] += (othervehicle.source_strength*(vehicle.position[0]-othervehicle.position[0]))/(2*np.pi*((vehicle.position[0]-othervehicle.position[0])**2+(vehicle.position[1]-othervehicle.position[1])**2))
            V_source[f,1] += (othervehicle.source_strength*(vehicle.position[1]-othervehicle.position[1]))/(2*np.pi*((vehicle.position[0]-othervehicle.position[0])**2+(vehicle.position[1]-othervehicle.position[1])**2))
            W_source[f,0] += (source_gain*othervehicle.source_strength*(vehicle.position[2]-othervehicle.position[2]))/(4*np.pi*((vehicle.position[0]-othervehicle.position[0])**2+(vehicle.position[1]-othervehicle.position[1])**2+(vehicle.position[2]-othervehicle.position[2])**2)**(3/2))

        if method == 'Vortex':
            for building in arenamap.buildings:
                u = np.zeros((building.nop,1))
                v = np.zeros((building.nop,1))
                polygon = Polygon(building.vertices)
                point = Point(vehicle.position[0],vehicle.position[1])
                #print('Vehicle' + str(f))
                #print(point)
                #print(polygon)
                if polygon.contains(point) == True:
                    #print(polygon.contains(point))
                    V_gamma[f,0] = V_gamma[f,0] + 0
                    V_gamma[f,1] = V_gamma[f,1] + 0
                    #print(polygon.contains(point))
                elif polygon.contains(point) == False:
                    #print(polygon.contains(point))
                    if vehicle.ID in building.gammas.keys():
                        # Velocity induced by vortices on each panel:

                        u = ( building.gammas[vehicle.ID][:].T/(2*np.pi))  *((vehicle.position[1]-building.pcp[:,1]) /((vehicle.position[0]-building.pcp[:,0])**2+(vehicle.position[1]-building.pcp[:,1])**2)) ####
                        v = (-building.gammas[vehicle.ID][:].T/(2*np.pi))  *((vehicle.position[0]-building.pcp[:,0]) /((vehicle.position[0]-building.pcp[:,0])**2+(vehicle.position[1]-building.pcp[:,1])**2))
                        V_gamma[f,0] = V_gamma[f,0] + np.sum(u)
                        V_gamma[f,1] = V_gamma[f,1] + np.sum(v)

        elif method == 'Source':
            for building in arenamap.buildings:
                u = np.zeros((building.nop,1))
                v = np.zeros((building.nop,1))
                polygon = Polygon(building.vertices)
                point = Point(vehicle.position[0],vehicle.position[1])
                #print('Vehicle' + str(f))
                #print(point)
                #print(polygon)
                if polygon.contains(point) == True:
                    #print(polygon.contains(point))
                    V_gamma[f,0] = V_gamma[f,0] + 0
                    V_gamma[f,1] = V_gamma[f,1] + 0
                    #print(polygon.contains(point))
                elif polygon.contains(point) == False:
                    #print(polygon.contains(point))
                    if vehicle.ID in building.gammas.keys():
                        # Velocity induced by vortices on each panel:

                        u = ( building.gammas[vehicle.ID][:].T/(2*np.pi))  *((vehicle.position[1]-building.pcp[:,1]) /((vehicle.position[0]-building.pcp[:,0])**2+(vehicle.position[1]-building.pcp[:,1])**2)) ####
                        v = (-building.gammas[vehicle.ID][:].T/(2*np.pi))  *((vehicle.position[0]-building.pcp[:,0]) /((vehicle.position[0]-building.pcp[:,0])**2+(vehicle.position[1]-building.pcp[:,1])**2))
                        V_gamma[f,0] = V_gamma[f,0] + np.sum(u)
                        V_gamma[f,1] = V_gamma[f,1] + np.sum(v)
        elif method == 'Hybrid':
            pass

########## !!!!!!FIX THIS!!!!!!!##########
##########  0*vehicle.V_inf[0] ###########
##########################################

        # Total velocity induced by all elements on map:
        V_sum[f,0] = V_gamma[f,0] + V_sink[f,0] + 0*vehicle.V_inf[0] + V_source[f,0]
        V_sum[f,1] = V_gamma[f,1] + V_sink[f,1] + 0*vehicle.V_inf[1] + V_source[f,1]

        # L2 norm of flow velocity:
        V_norm[f] = (V_sum[f,0]**2 + V_sum[f,1]**2)**0.5
        # Normalized flow velocity:
        V_normal[f,0] = V_sum[f,0]/V_norm[f]
        V_normal[f,1] = V_sum[f,1]/V_norm[f]

        # Flow velocity inversely proportional to velocity magnitude:
        V_flow[f,0] = V_normal[f,0]/V_norm[f]
        V_flow[f,1] = V_normal[f,1]/V_norm[f]

        # Add wind disturbance
        #V_flow[f,0] = V_flow[f,0] + U_wind
        #V_flow[f,1] = V_flow[f,0] + V_wind

        W_sum[f] = W_sink[f] + W_source[f]
        if W_sum[f] != 0.:
                W_norm[f] = (W_sum[f]**2)**0.5
                W_normal[f] = W_sum[f] /W_norm[f]
                W_flow[f] = W_normal[f]/W_norm[f]
                W_flow[f] = np.clip(W_flow[f],-0.07, 0.07)
        else:
                W_flow[f] = W_sum[f]

        flow_vels[f,:] = [V_flow[f,0], V_flow[f,1], W_flow[f,0]]

    return flow_vels

"""# Main"""

Arena  = ArenaMap(61,'manual')
ArenaR = deepcopy(Arena)
Arena.Inflate(radius = 0.15) #0.1
Arena.Panelize(size= 0.01) #0.08
Arena.Calculate_Coef_Matrix(method = 'Vortex')

Case = Cases(75,Arena,'manual')
Vehicle_list = Case.Vehicle_list

Vehicle_list[0].Set_Position([ 2, -0.5, 0.50])
Vehicle_list[0].Set_Goal([-2, 3, 0.5], 5, 0.00 )

Case = Cases(1,Arena,'random')
Vehicle_list = Case.Vehicle_list

Case = Cases(1171,Arena,'manual')
Vehicle_list = Case.Vehicle_list

"""# Simulate &  Plot"""

current_vehicle_list = Vehicle_list
vinfmag =  0.2
fig = plt.figure(figsize=(5,5))

minx = -5 #-2.5 # min(min(building.vertices[:,0].tolist()),minx)
maxx = 5 #3.5 # max(max(building.vertices[:,0].tolist()),maxx)
miny = -5 # -1 # min(min(building.vertices[:,1].tolist()),miny)
maxy = 5 # max(max(building.vertices[:,1].tolist()),maxy)

minx = -3 #-2.5 # min(min(building.vertices[:,0].tolist()),minx)
maxx = 3.5 #3.5 # max(max(building.vertices[:,0].tolist()),maxx)
miny = -3 # -1 # min(min(building.vertices[:,1].tolist()),miny)
maxy = 3.5 # max(max(building.vertices[:,1].tolist()),maxy)

plt.grid(color = 'k', linestyle = '-.', linewidth = 0.5)
for building in Arena.buildings:
    plt.plot(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'salmon', alpha=0.5 )
    plt.fill(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'salmon', alpha=0.5 )
for buildingR in ArenaR.buildings:
    plt.plot(     np.hstack((buildingR.vertices[:,0],buildingR.vertices[0,0]))  , np.hstack((buildingR.vertices[:,1],buildingR.vertices[0,1] )) ,'m' )
    plt.fill(     np.hstack((buildingR.vertices[:,0],buildingR.vertices[0,0]))  , np.hstack((buildingR.vertices[:,1],buildingR.vertices[0,1] )) ,'m' )
for _ in range(500):
    Flow_Vels = Flow_Velocity_Calculation(current_vehicle_list,Arena,method = 'Vortex')
    for index,vehicle in enumerate(current_vehicle_list):
        if (_ % 30 == 0):
            future_path, vinfmag  = vehicle.propagate_simple_path(vinfmag, Arena, hor = 3, reset_position = True)
            if (_ % 30 == 0):
                plt.plot(future_path[:,0],future_path[:,1], color='g', linewidth = 0.5, alpha = 0.6)
        vehicle.Go_to_Goal(AoAsgn = np.sign(vinfmag), Vinfmag = np.abs(vinfmag))                                           #def Go_to_Goal(self, altitude = 1.5, AoAsgn = 0, t_start = 0, Vinfmag = 0)
        vehicle.Update_Velocity(Flow_Vels[index],Arena)
plt.plot(Vehicle_list[0].path[:,0],Vehicle_list[0].path[:,1], linewidth = 2, alpha = 1)
plt.plot(Vehicle_list[0].path[0,0],Vehicle_list[0].path[0,1],'o')
plt.plot(Vehicle_list[0].goal[0],Vehicle_list[0].goal[1],'x')
plt.xlabel('East-direction --> (m)')
plt.ylabel('North-direction --> (m)')
plt.xlim([minx, maxx])
plt.ylim([miny, maxy])

current_vehicle_list = Vehicle_list
vinfmag_list = [0.05, 0.025, 0. , -0.025, -0.05]
fig = plt.figure(figsize=(5,5))

minx = -5 #-2.5 # min(min(building.vertices[:,0].tolist()),minx)
maxx = 5 #3.5 # max(max(building.vertices[:,0].tolist()),maxx)
miny = -5 # -1 # min(min(building.vertices[:,1].tolist()),miny)
maxy = 5 # max(max(building.vertices[:,1].tolist()),maxy)

minx = -3 #-2.5 # min(min(building.vertices[:,0].tolist()),minx)
maxx = 3.5 #3.5 # max(max(building.vertices[:,0].tolist()),maxx)
miny = -3 # -1 # min(min(building.vertices[:,1].tolist()),miny)
maxy = 3.5 # max(max(building.vertices[:,1].tolist()),maxy)

labellist = ['V_inf = 0.05','V_inf = 0.025','V_inf = 0.01','V_inf = 0.','V_inf = -0.01','V_inf = -0.025','V_inf = -0.05']
plt.grid(color = 'k', linestyle = '-.', linewidth = 0.5)
for building in Arena.buildings:
    plt.plot(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'salmon', alpha=0.5 )
    plt.fill(     np.hstack((building.vertices[:,0],building.vertices[0,0]))  , np.hstack((building.vertices[:,1],building.vertices[0,1] )) ,'salmon', alpha=0.5 )
for buildingR in ArenaR.buildings:
    plt.plot(     np.hstack((buildingR.vertices[:,0],buildingR.vertices[0,0]))  , np.hstack((buildingR.vertices[:,1],buildingR.vertices[0,1] )) ,'m' )
    plt.fill(     np.hstack((buildingR.vertices[:,0],buildingR.vertices[0,0]))  , np.hstack((buildingR.vertices[:,1],buildingR.vertices[0,1] )) ,'m' )
for _ in range(500):
    Flow_Vels = Flow_Velocity_Calculation(current_vehicle_list,Arena,method = 'Vortex')
    for index,vehicle in enumerate(current_vehicle_list):
        if (_ % 30 == 0):
            future_path = vehicle.propagate_future_path(vinfmag_list, hor = 3, reset_position = True, set_best_state = True)
            best = np.argmin([np.sum(curvature(future_path[i, 10:, 0],future_path[i, 10:, 1])) for i in range(5)])
            vinfmag = vinfmag_list[best]
            if (_ % 30 == 0):
                for i in range(5):
                    plt.plot(future_path[i,:,0],future_path[i,:,1], color='g', linewidth = 0.5, alpha = 0.6)
        #print('For vehicle ', str(index), 'Best V_inf is: ', str(vinfmag))
        vehicle.Go_to_Goal(AoAsgn = np.sign(vinfmag), Vinfmag = np.abs(vinfmag))                                           #def Go_to_Goal(self, altitude = 1.5, AoAsgn = 0, t_start = 0, Vinfmag = 0)
        vehicle.Update_Velocity(Flow_Vels[index],Arena)
plt.plot(Vehicle_list[0].path[:,0],Vehicle_list[0].path[:,1], linewidth = 2)
plt.plot(Vehicle_list[0].path[0,0],Vehicle_list[0].path[0,1],'o')
plt.plot(Vehicle_list[0].goal[0],Vehicle_list[0].goal[1],'x')
plt.xlabel('East-direction --> (m)')
plt.ylabel('North-direction --> (m)')
plt.xlim([minx, maxx])
plt.ylim([miny, maxy])